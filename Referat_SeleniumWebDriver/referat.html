<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8" />
  <title>Тестване на уеб приложения със Selenium WebDriver. Примери.</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <header class="site-header">
    <div class="container header-inner">
      <h1>Тестване на уеб приложения със Selenium WebDriver. Примери.</h1>
    </div>
  </header>
  <div class="layout">

    <aside class="sidebar">
      <nav class="sidebar-nav">
        <a href="#testing">1. Тестване</a>
        <a href="#selenium">2. Selenium</a>
        <a href="#architecture">3. Архитектура на Selenium WebDriver</a>
        <a href="#webdriver-usage">4. Работа с WebDriver</a>
        <a href="#pros-cons">5. Предимства и недостатъци</a>
        <a href="#sources">6. Източници</a>
      </nav>
    </aside>

  <main class="container main-content">

    <section id="testing" class="card">
      <h2>1. Какво представлява тестването</h2>

      <h3>Какво представлява?</h3>
      <p>
        Уеб тестването, а и тестването като цяло, представлява “проверка” на 
        функционалността и качеството на дадено приложение. В процеса на 
        тестване обикновено се използват предварително дефинирани тестови 
        сценарии, които специфицират очакваното поведение на дадена функционалност 
        или качеството на приложението и позволяват систематичната проверка на 
        тяхната коректност.
      </p>

      <h3>Защо е необходимо?</h3>
      <p>
        Необходимо е, за да верифицира качеството на продукта. Ако нещо не работи в 
        сайта, хората много бързо могат да загубят интерес, дори приложението да 
        работи във всички останали аспекти.
      </p>

      <h4>Статистики<sup><a href="#src1">[1]</a></sup></h4>
      <ul>
        <li>1 от 3 потребителя спират да използват сайт при лошо потребителско преживяване.</li>
        <li>57% от хората няма да препоръчат бизнес с лош дизайн на мобилната версия на сайта.</li>
        <li>88% от онлайн клиентите казват, че няма да се върнат към сайт, с който са имали лошо първоначално преживяване.</li>
      </ul>

      <h3>Видове тестване</h3>
      <p>Има няколко основни категоризации на тестването:</p>

      <h4>1. Според това какво се тества – функционално и нефункционално</h4>
      <p>
        <b>Функционалното тестване</b> проверява какво прави
        приложението – дали функциите работят според изискванията.
      </p>
      <p>
        <b>Нефункционалното тестване</b> проверява как работи
        приложението – неговите качества. Някои категории нефункционални тестове
        са:
      </p>
      <ul>
        <li>приемане от потребителя (acceptance)</li>
        <li>производителност (performance)</li>
        <li>ползваемост (usability)</li>
        <li>крос-браузърно тестване (cross-browser)</li>
        <li>и др.</li>
      </ul>

      <h4>2. Според това как се тества – ръчно и автоматично</h4>
      <p>
        <b>Ръчно тестване</b> – по определен тестов сценарий,
        специалистът изпълнява всички стъпки ръчно и наблюдава резултатите.
      </p>
      <p>
        <b>Автоматизирано тестване</b> – по определен тестов сценарий,
        специалистът, използвайки тестови фреймуъркове, симулира всички стъпки и
        сравнява резултатите с очакваните.
      </p>

      <h3>Предимства на автоматизацията</h3>
      <p>
        Някои от предимствата на автоматизацията са по-бързо и по-надеждно
        изпълнение, по-добър избор за по-големи проекти с чести обновления, не
        изисква ръчен труд при всяка регресия и намалява дългосрочните разходи. <sup><a href="#src2">[2]</a></sup>
      </p>
    </section>


    <section id="selenium" class="card">
      <h2>2. Selenium </h2>

      <h3>Кратка история на Selenium<sup><a href="#src3">[3]</a></sup></h3>
      <p>
        В началото, за да тестват приложения, разработчиците изпълнявали
        JavaScript команди директно в браузъра. Тази версия е известна като
        <b>Selenium Core</b>.
      </p>
      <p>
        По-късно бил въведен сървърен компонент, който играе ролята на прокси
        между тестовия скрипт и браузъра. Тази версия е известна като
        <b>Selenium Remote Control (Selenium RC)</b> или <b>Selenium 1</b>.
      </p>
      <p>
        След това била създадена нова кросплатформена библиотека, наречена
        <b>WebDriver</b>, която използва вградени API-та за
        автоматизация на браузъра вместо инжектиране на JavaScript.
      </p>
      <p>
        Накрая Selenium WebDriver и Selenium RC били комбинирани, създавайки
        <b>Selenium 2</b>. Над него през годините се надгражда и се
        развива до <b>Selenium 3</b>, а по-късно и
        <b>Selenium 4</b>.
      </p>

      <h3>Какво е Selenium</h3>
      <p>
        <b>Selenium</b> е популярен софтуерен фреймуърк с отворен код,
        използван за автоматизирано тестване на уеб приложения. Той се прилага
        широко при функционално тестване, регресионно тестване и тестване на
        производителността.
      </p>
      <p>
        Selenium поддържа множество програмни езици, включително Java, C#,
        Python и т.н., което го прави достъпен за голям кръг разработчици.
      </p>
      <p>
        В ролята си на фреймуърк Selenium включва следните компоненти:
      </p>
      <ul>
        <li>
          <b>Selenium IDE</b> – инструмент, който позволява на
          потребителите без писане на код да записват действията си в браузъра и
          автоматично да ги превръщат в тестови сценарии. По същество е
          разширение на браузър.
        </li>
        <li>
          <b>Selenium RC</b> – инструмент, който позволява изпълнение
          на тестове, написани на различни програмни езици, управлявайки
          браузъра чрез JavaScript инжекции.
        </li>
        <li>
          <b>Selenium WebDriver</b> – основният инструмент, с който се
          автоматизират тестове за уеб приложения чрез реално управление на
          браузъра. Позволява на тестовите скриптове да взаимодействат с уеб
          елементи по същия начин, по който би го направил истински потребител –
          кликове, писане, навигация и т.н.
        </li>
        <li>
          <b>Selenium Grid</b> – инструмент за паралелно и
          разпределено изпълнение на тестове върху множество машини, браузъри и
          операционни системи.
        </li>
      </ul>
    </section>

    <section id="architecture" class="card">
      <h2>3. Архитектура на Selenium WebDriver</h2>
      <p>
        Моделът на архитектурата е клиент–сървър, при който тестовият код
        изпраща команди към браузъра, а браузърът връща резултат.
      </p>

      <h3>Основни компоненти</h3>
      <h4>Клиентска библиотека за Selenium</h4>
      <p>
        Selenium предоставя поддръжка за множество библиотеки като Ruby, Python,
        Java и др. под формата на езикови обвързвания (language bindings).
        Чрез тази библиотека пишем кода за автоматизация.
      </p>

      <h4>Протокол за комуникация</h4>
      <p>
        В <strong>Selenium 3</strong> протоколът е <em>JSON Wire Protocol</em>,
        предаван чрез HTTP – той управлява данните чрез междинен слой.
      </p>
      <p>
        В <strong>Selenium 4</strong> се използва <em>W3C WebDriver</em>
        стандарт, който прави комуникацията по-стабилна, по-бърза и по-надеждна.
      </p>

      <h4>Браузърни драйвъри</h4>
      <p>
        Драйвърите на браузърите в Selenium са специфични за всеки отделен
        браузър и взаимодействат с него чрез установяване на защитена връзка.
        Selenium поддържа различни браузърни драйвъри. Те действат като посредници, 
        които разбират инструкциите от Selenium и ги изпълняват в реалния браузър, 
        тъй като вътрешната логика на браузърите е затворена и недостъпна за директна манипулация.
      </p>

      <h4>Браузъри</h4>
      <p>
        Selenium предоставя поддръжка за множество браузъри. След обработване на
        заявките драйвърът подава командите към инсталирания браузър чрез
        вътрешен HTTP сървър, а получените отговори се връщат обратно към
        клиента.
      </p>

      <table class="driver-table">
        <thead>
          <tr>
            <th>Браузър</th>
            <th>Драйвър</th>
            <th>Поддържана операционна система</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Google Chrome / Chromium </td>
            <td>ChromeDriver</td>
            <td>Windows/macOS/Linux</td>
          </tr>
          <tr>
            <td>Mozilla Firefox</td>
            <td>GeckoDriver</td>
            <td>Windows/macOS/Linux</td>
          </tr>
          <tr>
            <td>Microsoft Edge WebDriver</td>
            <td>Edge WebDriver</td>
            <td>Windows/macOS/Linux</td>
          </tr>
          <tr>
            <td>Safari</td>
            <td>SafariDriver (in-built)</td>
            <td>macOS Sierra и по-нови</td>
          </tr>
        </tbody>
      </table><sup><a href="#src4">[4]</a></sup>

      <div class="architecture-images">
        <figure>
            <img src="img/S3_arch.jpeg" alt="Архитектура Selenium 3">
            <figcaption>Selenium 3 - архитектура<sup><a href="#src5">[5]</a></sup></figcaption>
        </figure>
        <figure>
            <img src="img/S4_arch.jpeg" alt="Архитектура Selenium 4">
            <figcaption>Selenium 4 - архитектура<sup><a href="#src5">[5]</a></sup></figcaption>
        </figure>
      </div>
    </section>

    <section id="webdriver-usage" class="card">
      <h2>4. Работа с WebDriver</h2>

      <p>
        Въпреки че Selenium поддържа широк набор от програмни езици като Java,
        C#, Ruby и други, в настоящия реферат всички примери и демонстрации са
        реализирани на <b>Python</b>. Драйвърът, с който ще бъде използван, 
        е <b>ChromDriver</b>. За демо ще бъдат използвани елементи от следния сайт 
        <a href="https://www.qa-practice.com/">https://www.qa-practice.com/</a>.
      </p>

      <h3>Настройка на среда</h3>
      <p>
        За да започнем работа със Selenium WebDriver, първо трябва да добавим
        официалната библиотека към проекта чрез пакетен мениджър като
        <code>pip</code> за Python, <code>NuGet</code> за C# и т.н.
      </p>
      <div class="code-block">
        <pre><code class="language-python">
# следната команда се изпълнява в терминала
pip install selenium
# ако операционната система е macOS да се изпълни:
# pip3 install selenium
        </code></pre>
      </div>
      
      <p>
        След това е необходимо да се изтегли и конфигурира подходящ браузърен
        драйвър – например ChromeDriver, Edge WebDriver и др. Драйвърът трябва да
        бъде поставен в директория, достъпна за системата, или пътят до него да
        бъде зададен ръчно в кода. Драйвърът трябва да съвпада с текущата версия
        на браузърът. Това става по следният начин:
        <ol>
            <li>
                Сваля се stable версията, която съответства на Chrome версията, на ChromeDriver 
                от следния сайт 
                <a href="https://googlechromelabs.github.io/chrome-for-testing/">
                https://googlechromelabs.github.io/chrome-for-testing/
                </a>. 
            </li>
            <li>
                Изтеглената папка трябва да се разархивира и chromedriver.exe (за macOS или Linux - chromedriver) файлът от нея да се постави на 
                известно място (най-удобно е в папката на проекта). Ако операционната система е macOS или Linux, 
                файлът трябва да се сложи в /usr/local/bin директорията.
            </li>
        </ol>
      </p>
      <p>
        След успешното свързване между Selenium и драйвъра, разработчикът може
        да стартира браузъра програмно и да автоматизира различни тестови
        сценарии.
      </p>

      <h3>Локатори – откриване на елементи</h3>
      <p>
        Първото нещо, което трябва да се направи, за да се започне тестване, е
        да се стартира инстанция на драйвъра за съответния браузър. Този обект
        ще бъде отговорен за извикването на необходимите функции към драйвъра.
      </p>
      <div class="code-block">
        <pre><code class="language-python">
from selenium import webdriver
from selenium.webdriver.chrome.service import Service

# указване на пътя (ако ОС е macOS или Linux, в скобите пишем /usr/local/bin/chromedriver)
service = Service(executable_path="chromedriver.exe")

# Стартиране на Chrome браузър
driver = webdriver.Chrome()
        </code></pre>
      </div>

      <h3>Основни действия</h3>
      <p>
        Оттук насетне в страницата, която сме заредили, можем да автоматизираме широк 
        набор от потребителски действия. В този раздел ще бъдат показани само няколко 
        основни примера като кликане, въвеждане на текст, избор от падащи списъци и 
        скролване. 
      </p>

      <p>
        За да бъдат открити елементите, WebDriver използва локатори като
        <code>ID</code>, <code>CLASS_NAME</code>, <code>NAME</code>,
        <code>CSS_SELECTOR</code>, <code>TAG_NAME</code>, 
        <code>LINK_TEXT</code>, <code>PARTIAL_LINK_TEXT</code> и 
        <code>XPath</code><sup><a href="#src4">[6]</a></sup>. За тази цел се използва
        класът By, който трябва да бъде добавен допълнително:
      </p>

      <div class="code-block">
        <pre><code class="language-python">
from selenium.webdriver.common.by import By
        </code></pre>
      </div>
      
      <p>
        Оттук насетне в страницата, която сме заредили, можем да автоматизираме широк 
        набор от потребителски действия. В този раздел ще бъдат показани само няколко 
        основни примера като кликане, въвеждане на текст, избор от падащи списъци и 
        скролване. 
      </p>

      <p>
        За да се кликне бутон, открит по неговия ID, може да се използва метода click(). 
        За пример се взима бутонът на следната страница 
        <a href="https://www.qa-practice.com/elements/button/simple">
            https://www.qa-practice.com/elements/button/simple
        </a>.
      </p>

      <div class="code-block">
        <pre><code class="language-python">
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By

# указване на пътя (ако ОС е macOS или Linux, в скобите пишем /usr/local/bin/chromedriver)
service = Service(executable_path="chromedriver.exe")

# Стартиране на Chrome браузър
driver = webdriver.Chrome()

driver.get("https://www.qa-practice.com/elements/button/simple")

driver.find_element(By.ID, "submit-id-submit").click()
        </code></pre>
      </div>

      <p>
        Въвеждането на текст в поле по име се извършва чрез метода send_keys() (за пример се взима бутонът на следната страница 
        <a href="https://www.qa-practice.com/elements/input/simple">
            https://www.qa-practice.com/elements/input/simple
        </a>).
      </p>

      <div class="code-block">
        <pre><code class="language-python">
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By

# указване на пътя (ако ОС е macOS или Linux, в скобите пишем /usr/local/bin/chromedriver)
service = Service(executable_path="chromedriver.exe")

# Стартиране на Chrome браузър
driver = webdriver.Chrome()

driver.get("https://www.qa-practice.com/elements/input/simple")

driver.find_element(By.NAME, "text_string").send_keys("test_user")
        </code></pre>
      </div>


      <p>
        Изборът на стойност от падащо меню чрез видим текст става чрез класа Select, 
        който трябва да се добави към проекта (за пример се взима менюто на следната страница 
        <a href="https://automationtesting.co.uk/dropdown.html">
            https://automationtesting.co.uk/dropdown.html
        </a>).
      </p>

      <div class="code-block">
        <pre><code class="language-python">
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By

# указване на пътя (ако ОС е macOS или Linux, в скобите пишем /usr/local/bin/chromedriver)
service = Service(executable_path="chromedriver.exe")

# Стартиране на Chrome браузър
driver = webdriver.Chrome()

driver.get("https://automationtesting.co.uk/dropdown.html")

driver.find_element(By.NAME, "cars").send_keys("Suzuki")
        </code></pre>
      </div>

      <p>
        Скролване до елемент може да се постигне по следния начин (за пример се взима менюто на следната страница 
        <a href="https://www.qa-practice.com/elements/input/simple">
            https://www.qa-practice.com/elements/input/simple
        </a>):
      </p>

      <div class="code-block">
        <pre><code class="language-python">
from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By

# указване на пътя (ако ОС е macOS или Linux, в скобите пишем /usr/local/bin/chromedriver)
service = Service(executable_path="chromedriver.exe")

# Стартиране на Chrome браузър
driver = webdriver.Chrome()

driver.get("https://www.qa-practice.com/elements/button/simple")

element = driver.find_element(By.TAG_NAME, "footer"), driver.execute_script("arguments[0].scrollIntoView();", element)
        </code></pre>
      </div>

      <h3>Изчаквания – implicit, explicit, fluent wait</h3>
      <p>
        При автоматизираното тестване често е необходимо да се изчака
        определено събитие, за да продължи изпълнението на тестовия сценарий.
        Това се налага, защото елементите на страницата може да се зареждат
        динамично или да се появяват след действие.
      </p>

      <h4>Implicit wait</h4>
      <p>
        Задава глобално време за изчакване, през което WebDriver периодично
        проверява дали елементът е наличен. Също така е вграден в самия WebDriver 
        и не изисква импорт на отделен клас
      </p>

      <div class="code-block">
        <pre><code class="language-python">
from selenium import webdriver
from selenium.webdriver.chrome.service import Service

# указване на пътя (ако ОС е macOS или Linux, в скобите пишем /usr/local/bin/chromedriver)
service = Service(executable_path="chromedriver.exe")

# Стартиране на Chrome браузър
driver = webdriver.Chrome()

# Глобално изчакване до 10 секунди
driver.implicitly_wait(10)
        </code></pre>
      </div>

      <h4>Explicit wait</h4>
      <p>
        Използва се, когато трябва да се изчака конкретно условие, като
        видимост или кликаемост на даден елемент. Това се постига чрез 
        класа WebDriverWait, който се добавя от библиотеката 
        selenium.webdriver.support.ui, и предварително дефинирано очаквано 
        условие, което се дефинира чрез класа expected_conditions от библиотеката 
        selenium.webdriver.support (за пример се взима Click бутона на следната страница 
        <a href="https://www.qa-practice.com/elements/button/simple">
            https://www.qa-practice.com/elements/button/simple
        </a>. Той е активен, но нека за тестови цели предположим, че е неактивен).
      </p>

      <div class="code-block">
        <pre><code class="language-python">
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# указване на пътя (ако ОС е macOS или Linux, в скобите пишем /usr/local/bin/chromedriver)
driver = webdriver.Chrome()

# Стартиране на Chrome браузър
driver.get("https://www.qa-practice.com/elements/button/simple")

wait = WebDriverWait(driver, 10)

# Изчакваме елементът да стане видим
practice_btn = wait.until(
    EC.visibility_of_element_located((By.ID, "submit-id-submit"))
)

# Изчакваме да бъде кликаем
practice_btn = wait.until(
    EC.element_to_be_clickable((By.ID, "submit-id-submit"))
)

practice_btn.click()
        </code></pre>
      </div>

      <h4>Fluent wait</h4>
      <p>
        Разширява възможностите на explicit wait, като позволява максимално
        време на чакане, интервал между опитите и списък с изключения, които да
        бъдат игнорирани. Използва се при по-сложни сценарии, където времето за 
        зареждане е непредвидимо. Реализира се чрез WebDriverWait в комбинация с 
        poll_frequency за интервал на опитите и собствена функция или 
        ignored_exceptions за игнориране на грешки (за пример се взима Click бутона на следната страница 
        <a href="https://www.qa-practice.com/elements/button/simple">
            https://www.qa-practice.com/elements/button/simple
        </a>. Той е активен, но нека за тестови цели предположим, че е неактивен).
      </p>

      <div class="code-block">
        <pre><code class="language-python">
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# указване на пътя (ако ОС е macOS или Linux, в скобите пишем /usr/local/bin/chromedriver)
driver = webdriver.Chrome()

# Стартиране на Chrome браузър
driver.get("https://www.qa-practice.com/elements/button/simple")

wait = WebDriverWait(
    driver, 
    timeout=20,
    poll_frequency=0.5,
    ignored_exceptions=[NoSuchElementException, ElementNotInteractableException]
)

# Изчакваме да бъде кликаем
practice_btn = wait.until(
    EC.element_to_be_clickable((By.ID, "submit-id-submit"))
)

practice_btn.click()
        </code></pre>
      </div>

      <h3>Динамични елементи, pop-ups и alerts</h3>
      <p>
        В уеб приложенията често се срещат динамични елементи, изскачащи
        прозорци (pop-ups) и системни известия (alerts), които изискват
        специална обработка.
      </p>

      <h4>Динамични елементи</h4>
      <p>
        Обикновено се комбинират с explicit wait, за да се изчака те да
        станат видими или кликаеми (виж примера за explicit wait в предходния 
        раздел).
      </p>

      <h4>HTML pop-ups (нов прозорец/таб)</h4>
      <p>
        Изскачащите прозорци (HTML pop-ups) обикновено представляват отделни 
        прозорци или нови табове. За тях се превключва към съответния прозорец 
        чрез window handles. (за пример се взима pop-up-a на следната страница 
        <a href="https://www.qa-practice.com/elements/popup/modal">
            https://www.qa-practice.com/elements/popup/modal
        </a>).
      </p>
      <div class="code-block">
        <pre><code class="language-python">
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

# указване на пътя (ако ОС е macOS или Linux, в скобите пишем /usr/local/bin/chromedriver)
driver = webdriver.Chrome()

# Стартиране на Chrome браузър
driver.get("https://www.qa-practice.com/elements/popup/modal")

main_window = driver.current_window_handle

driver.find_element(By.CLASS_NAME, "btn btn-primary").click()

for handle in driver.window_handles:
    if handle != main_window:
        driver.switch_to.window(handle)
        break

driver.find_element(By.CLASS_NAME, "btn-close").click()
driver.close()
driver.switch_to.window(main_window)
        </code></pre>
      </div>

      <h4>JavaScript alerts</h4>
      <p>
        JavaScript <code>alert</code> прозорците трябва да бъдат прихванати и
        обработени, преди тестът да продължи. Selenium предоставя вграден интерфейс 
        за работа с тях.
      </p>

      <div class="code-block">
        <pre><code class="language-python">
alert = driver.switch_to.alert
print(alert.text)
alert.accept()  # или alert.dismiss()
        </code></pre>
      </div>

      <h3>Избягване на робот проверки</h3>
      <p>
        Когато уеб приложение открие автоматизиран достъп, то често активира
        защитни механизми като CAPTCHA, ограничаване на честотата на заявките
        или временно блокиране на IP адреса.
      </p>
      <p>
        Някои подходи включват използване на <code>undetected_chromedriver</code>,
        динамични User-Agent стойности, ротация на IP чрез проксита или
        облачни инстанции, както и имитиране на човешко поведение чрез
        забавяния, движения и скролване.
      </p>
      <p class="note">
        <b>Важно</b>: тези техники трябва да се използват само в рамките на закона и
        при стриктно спазване на условията за ползване на съответния уебсайт,
        за да се избегне неправомерен достъп или злоупотреба с информация.
      </p>
    </section>

    <section id="pros-cons" class="card">
      <h2>5. Предимства и недостатъци на Selenium WebDriver<sup><a href="#src3">[7]</a></sup></h2>

      <h3>Предимства</h3>
      <ol>
        <li>
          Selenium WebDriver е напълно безплатен и с отворен код, което го прави
          достъпна алтернатива на комерсиални решения като UFT. Липсата на такси 
          за лицензи позволява използването му от компании с различен мащаб, а 
          голямата и активна общност осигурява бърза помощ при проблеми и богата 
          база от знания за справяне с възникнали затруднения. 
        </li>
        <li>
          Selenium WebDriver е гъвкав инструмент, тъй като позволява писане на 
          автоматизирани тестове на различни програмни езици. Поддържат се 
          популярни езици като Java, Python, C#, JavaScript, Ruby и Kotlin, 
          което дава свобода на екипите да работят с технологиите, които 
          вече използват. Това го прави удобен за интеграция в разнообразни 
          проекти и достъпен за тестъри и разработчици с различен технически опит. 
        </li>
        <li>
          Selenium WebDriver предлага висока степен на съвместимост между различните 
          браузъри, което позволява тестовете да бъдат изпълнявани последователно в 
          Chrome, Firefox, Edge, Safari, Opera и други популярни среди. Това се постига 
          чрез използването на специализирани драйвери за всеки бразуър, като 
          ChromeDriver за Chrome или GeckoDriver за Firefox, които осигуряват 
          коректната комуникация между тестовия скрипт и конкретния браузър. 
          Тази универсалност прави WebDriver ефективен инструмен за гарантиране на 
          еднакво поведение на уеб приложенията в различни браузърни платформи.
        </li>
        <li>
          Selenium WebDriver предлага пълна кросплатформена поддръжка, което позволява 
          тестовете да бъдат изпълнявани на Windows, macOS и Linux без нужда от 
          промяна в тестовите сценарии. Освен това WebDriver се интегрира лесно с CI/CD 
          инструменти като Jenkins и GitHub Actions, което улеснява автоматизираното 
          тестване в рамките на модерни DevOps процеси.
        </li>
        <li>
          За разлика от остарелия Selenium RC, WebDriver комуникира директно с браузъра 
          чрез системни команди на операционната система. Това премахва нуждата от междинен 
          сървър или прокси слой, осигурявайки по-бързо, стабилно и надеждно изпълнение на 
          тестовете.
        </li>
        <li>
          Selenium WebDriver се интегрира с множество тестови фреймуърци като TestNG и 
          JUnit за Java, pytest за Python, NUnit за C#, Mocha за JavaScript и Cucumber. 
          Това позволява реализиране на различни тестови стратегии, включително data-driven, 
          keyword-driven и хибриден подход.
        </li>
        <li>
          С помощта на Selenium Grid тестовете могат да бъдат изпълнявани паралелно върху 
          различни машини, операционни системи и браузъри. Това значително намалява общото 
          време за изпълнение и улеснява мащабиране на автоматизираните тестови среди.
        </li>
      </ol>

      <h3>Недостатъци</h3>
      <ol>
        <li>
          Selenium WebDriver не предлага собствен механизъм за генериране на тестови отчети, 
          което налага използването на външни инструменти като Allure, ExtentReports или вградените 
          възможности на TestNG. Това усложнява процеса на анализ, но позволява изграждане на 
          гъвкави персонализирани репорти чрез допълнителни плъгини и скриптове.
        </li>
        <li>
          Работата със Selenium изисква добри умения по програмиране, разбиране на CSS/XPath 
          локатори и познаване на автоматизационни фреймуърци. Това може да затрудни начинаещите, 
          които често започват с по-опростени решения като Selenium IDE или low-code инструменти 
          като Katalon Studio.
        </li>
        <li>
          Selenium WebDriver не предлага собствен механизъм за паралелно изпълнение на тестове. 
          За тази цел се използват Selenium Grid, TestNG, pytest-xdist или облачни платформи като 
          BrowserStack и Sauce Labs, което позволява значително съкращаване на времето за изпълнение.
        </li>
        <li>
          Тестовете често се „чупят“ при промени в потребителския интерфейс, тъй като се налага 
          актуализация на локаторите. Прилагането на Page Object Model и използването на относителните 
          локатори в Selenium 4 намаляват необходимостта от поддръжка.
        </li>
        <li>
          Selenium не може да валидира OTP кодове, имейли или SMS известия. Това обикновено се решава 
          чрез интеграции с външни услуги като MailSlurp или Twilio, или чрез директни заявки към база 
          данни/API.
        </li>
        <li>
          Поради архитектурата си, основана на комуникация между драйвър и браузър, Selenium е по-бавно 
          от инструменти като Cypress или Playwright. Използването на headless режим може да подобри 
          скоростта на изпълнение.
        </li>
        <li>
          WebDriver не може да валидира изображения или CAPTCHA. За визуални проверки се използват 
          библиотеки като SikuliX или OpenCV, които работят с разпознаване на образи.
        </li>
      </ol>
    </section>
    <section id="sources" class="card">
        <h2>Източници</h2>
        <ol>
            <li id="src1">
                [<a href="https://www.browserstack.com/guide/how-to-perform-website-qa-testing">
                https://www.browserstack.com/guide/how-to-perform-website-qa-testing
                </a>], последно посетен на 2025-12-08.</li>
            <li id="src2">
                [<a href="https://katalon.com/resources-center/blog/what-is-web-testing">
                https://katalon.com/resources-center/blog/what-is-web-testing
                </a>], последно посетен на 2025-12-08.</li>
            <li id="src3">
                [<a href="https://www.browserstack.com/guide/architecture-of-selenium-webdriver">
                https://www.browserstack.com/guide/architecture-of-selenium-webdriver
                </a>], последно посетен на 2025-12-08.</li>
            <li id="src4">
                [<a href="https://www.browserstack.com/guide/selenium-webdriver-tutorial#:~:text=Selenium%20WebDriver%20is%20the%20core,user%20interactions%20and%20perform%20assertions.">
                https://www.browserstack.com/guide/selenium-webdriver-tutorial#:~:text=Selenium%20WebDriver%20is%20the%20core,user%20interactions%20and%20perform%20assertions.
                </a>], последно посетен на 2025-12-08.</li>
            <li id="src5">
                [<a href="https://www.qable.io/blog/what-is-the-difference-between-selenium-3-and-selenium-4">
                https://www.qable.io/blog/what-is-the-difference-between-selenium-3-and-selenium-4
                </a>
                ], последно посетен на 2025-12-08.
            </li>
            <li id="src6">[
                <a href="https://www.selenium.dev/documentation/webdriver/elements/locators/">
                https://www.selenium.dev/documentation/webdriver/elements/locators/
                </a>], последно посетен на 2025-12-08.
            </li>
            <li id="src7">[
                <a href="https://vinothqaacademy.com/docs/advantages-and-disadvantages-of-selenium-webdriver/">
                https://vinothqaacademy.com/docs/advantages-and-disadvantages-of-selenium-webdriver/
                </a>], последно посетен на 2025-12-08.
            </li>
        </ol>
    </section>
  </main>

  <script src="script.js"></script>
</body>
</html>